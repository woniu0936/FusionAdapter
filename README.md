# üöÄ FusionAdapter

[![Maven Central](https://img.shields.io/maven-central/v/io.github.woniu0936/fusion-core)](https://search.maven.org/artifact/io.github.woniu0936/fusion-core)
[![Kotlin](https://img.shields.io/badge/language-Kotlin-orange.svg)](https://kotlinlang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](./LICENSE)
[![Paging3](https://img.shields.io/badge/Support-Paging3-green)](https://developer.android.com/topic/libraries/architecture/paging/v3)

[üá®üá≥ ‰∏≠ÊñáÊñáÊ°£](./README_CN.md) | [üá∫üá∏ English](./README.md)

**FusionAdapter** is a modern, fail-safe RecyclerView adapter library designed for the Kotlin era.

It eliminates the tedious boilerplate of ViewHolders, ViewTypes, and DiffUtils, allowing you to build complex heterogeneous lists using a concise **Kotlin DSL**. With built-in **Data Sanitization**, **Native Paging 3 Support**, and **ViewBinding**, it bridges the gap between your data and UI with zero friction.

üîó **GitHub**: [https://github.com/woniu0936/FusionAdapter](https://github.com/woniu0936/FusionAdapter)

---

## üÜö Why FusionAdapter?

FusionAdapter is not just another MultiType library. It is a next-generation adapter solution built to tackle **"Boilerplate Explosion"**, **"Concurrency Safety"**, and **"Paging 3 Integration Pain"** in large-scale Android projects.

| Feature | **FusionAdapter** | **Epoxy (Airbnb)** | **MultiType** | **BRVAH (v4)** |
| :--- | :--- | :--- | :--- | :--- |
| **Paradigm** | **Reactive DSL** (In-place) | Annotation Driven | Class Mapping | Inheritance Driven |
| **Boilerplate** | **Zero (Minimalist)** | High (Many Model classes) | Medium (Binders req.) | Medium (Base classes) |
| **Data Safety** | **Sanitization Engine**<br>Silently drops bad data | Implicit Ignore | Fail-Fast (Crash) | Undefined (Visual glitches) |
| **Paging 3** | **First-class Support**<br>Auto Placeholder/ID mgmt | Extension lib req. | No native support | Compatibility mode |
| **Build Penalty** | **Zero (Runtime only)** | **Significant (KAPT/KSP)** | Zero | Zero |
| **Concurrency** | **Immutable Runtime** | Internal Sync | Thread-Unsafe | Thread-Unsafe |
| **Learning Curve** | **Ultra Low** | Very High | Low | Medium |

### üí° Core Value: Why it belongs in your project?

1.  **No More "Class Explosion"**: Traditional solutions require a new `ViewHolder` or `ItemBinder` class for every single UI style. With FusionAdapter, you just add a few lines to your DSL, keeping your codebase lean and maintainable.
2.  **Built for Production Stability**: In large projects, backend responses might occasionally contain undefined types. FusionAdapter's **Sanitization mechanism** ensures that in Release builds, these invalid items are safely filtered out instead of crashing your app.
3.  **Zero Build Overhead**: Unlike Epoxy, which can add seconds to your build time via annotation processing, FusionAdapter has zero build-time impact, keeping your development cycle fast.
4.  **Flawless Animation UX**: Combined with **Cascading Stable IDs** generated by the FNV-1a 64-bit algorithm, FusionAdapter provides textbook-perfect RecyclerView animations, even in complex asynchronous Paging scenarios.

---

## ‚ú® Key Features

*   **‚ö° Minimalist DSL**: Launch a multi-type list in a single block of code. No more creating separate Adapter/ViewHolder classes.
*   **üõ°Ô∏è Robust Sanitization**:
    *   **Debug**: Crashes immediately on unregistered types to catch bugs early (Fail-Fast).
    *   **Release**: Silently drops invalid data to prevent crashes and layout corruption (Fail-Safe).
*   **üßµ Concurrency Safe**: Built on an **Immutable Runtime** for thread-safe operations and extreme performance.
*   **üìÑ Native Paging 3**: A dedicated `FusionPagingAdapter` deeply integrated with Paging 3. Supports **deterministic placeholder IDs** to fix UI flickering.
*   **üîÄ Cascading Stable ID Strategy**:
    *   Supports **Router-level (Shared)** and **Delegate-level (Override)** ID configurations.
    *   Built-in FNV-1a 64-bit hashing to resolve ID collisions across heterogeneous types.
*   **üìê Layout Intelligence**: Declare `spanSize` and `fullSpan` logic directly within the item configuration.
*   **üöÄ Memory & Logging Safety**:
    *   **Auto Leak Prevention**: Automatically clears view tags in `onViewRecycled` to strictly prevent memory leaks.
    *   **Enterprise Logging**: High-performance async logging. Support for stripping debug logs in Release builds via ProGuard.
*   **‚òï Java Friendly**: Beyond Kotlin DSL, it provides full **Builder Pattern** support for Java developers.

---

## üì¶ Installation

Add the dependency to your module-level `build.gradle.kts`:

```kotlin
dependencies {
    implementation("io.github.woniu0936:fusion-core:0.7.0")
    // Optional: Native Paging 3 support
    implementation("io.github.woniu0936:fusion-paging:0.7.0")
}
```

---

## üî® Usage Guide

### 1. Simple List (DSL)

Map a data type to a layout and bind it.

```kotlin
// In Activity / Fragment
val adapter = recyclerView.setupFusion {
    
    // Register: Data Type (String) -> Layout (ItemTextBinding)
    register(ItemTextBinding::inflate) {
        
        // Configure Stable ID for performance (Optional)
        stableId { it }
        
        // onBind: 'this' is the ViewBinding, 'item' is the data
        onBind { item ->
            tvTitle.text = item
        }

        // onItemClick: Handle click events
        onItemClick { item ->
            toast("Clicked: $item")
        }
    }
}

// Submit list
adapter.submitList(listOf("Hello", "Fusion", "Adapter"))
```

### 2. Polymorphism (Cascading Stable ID)

Handle scenarios where the same data class (`Message`) renders different layouts based on its state.

```kotlin
data class Message(val id: Long, val type: Int, val content: String)

recyclerView.setupFusion {
    register<Message> {
        
        // [Level 1] Router Level ID config
        stableId { it.id }

        // Define routing logic
        match { it.type }

        // [Inherit] Inherits Level 1 stableId automatically
        map(TYPE_TEXT, ItemMsgTextBinding::inflate) {
            onBind { msg -> ... }
        }

        // [Override] Override ID for special cases to prevent conflicts
        map(TYPE_TIMELINE, ItemTimeLineBinding::inflate) {
            // [Level 2] Delegate Level ID (Higher priority)
            stableId { "${it.id}_time" }
            onBind { msg -> ... }
        }
    }
}
```

### 3. Paging 3 Integration

Dedicated adapter for Paging 3 with seamless integration.

```kotlin
val pagingAdapter = FusionPagingAdapter<User>()

pagingAdapter.apply {
    // Regular registration
    register(ItemUserBinding::inflate) {
        onBind { user -> ... }
    }
    
    // Optional: Register a custom placeholder (Skeleton)
    registerPlaceholder(ItemSkeletonBinding::inflate) {
        onBind { /* Setup shimmer animation */ }
    }
}

// Submit PagingData
lifecycleScope.launch {
    viewModel.pagingFlow.collectLatest { pagingData ->
        pagingAdapter.submitData(pagingData)
    }
}
```

### 4. Grid & Staggered Support

Control spans directly in the DSL. Fusion handles `SpanSizeLookup` automatically.

```kotlin
val layoutManager = GridLayoutManager(context, 2)
recyclerView.layoutManager = layoutManager

recyclerView.setupFusion(layoutManager) {
    
    // Header: Always full span
    register<Header>(ItemHeaderBinding::inflate) {
        onBind { ... }
        fullSpanIf { true } 
    }

    // Grid Item: Dynamic span
    register<GridItem>(ItemGridBinding::inflate) {
        onBind { ... }
        spanSize { item, position, scope -> 
            if (item.isPromoted) scope.totalSpans else 1 
        }
    }
}
```

### 5. Java Interoperability (Builder Pattern)

Fusion is friendly to Java developers. You can use `TypeRouter.Builder` for type-safe registration.

```java
// Java Example
FusionAdapter adapter = new FusionAdapter();

// Configure routing using the Builder pattern
TypeRouter<User> userRouter = new TypeRouter.Builder<User>()
    .match(user -> user.getRole())
    .map("ADMIN", new AdminDelegate())
    .map("USER", new UserDelegate())
    .build();

adapter.register(User.class, userRouter);
recyclerView.setAdapter(adapter);
```

---

## ‚öôÔ∏è Advanced Features

### 1. Partial Updates & Property-Level Binding (Payloads)

By combining `onPayload` with Kotlin property references, FusionAdapter achieves **"View-specific"** updates. Only the code corresponding to the changed property is executed, completely eliminating flickering in complex items.

```kotlin
register<Post>(ItemPostBinding::inflate) {
    onBind { post -> /* Full Binding */ }

    // [Single Property] Only updates tvLikeCount when likeCount changes
    onPayload(Post::likeCount) { count ->
        tvLikeCount.text = count.toString()
    }

    // [Multi-Property] Triggered if either avatar or nickname changes
    onPayload(Post::avatar, Post::nickname) { avatar, name ->
        ivAvatar.load(avatar)
        tvName.text = name
    }
}
```

### 2. Manual Skeleton Control (Skeleton API)

In non-paging mode, you can manipulate placeholders just like regular data:

```kotlin
// 1. Register placeholder style
adapter.registerPlaceholder(ItemSkeletonBinding::inflate) {
    onBind { /* Configure skeleton animations */ }
}

// 2. Show placeholders (Skeleton mode)
adapter.showPlaceholders(count = 10)

// 3. Clear them when async data arrives
adapter.clearPlaceholders()
adapter.setItems(realData)
```

---

## ‚òï Java Interoperability

FusionAdapter provides full support for Java developers.

```java
// 1. Implement Delegate
public class UserDelegate extends JavaDelegate<User, ItemUserBinding> {
    @Override
    public Object getStableId(@NonNull User item) {
        return item.getId();
    }

    @Override
    protected ItemUserBinding onCreateBinding(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) {
        return ItemUserBinding.inflate(inflater, parent, false);
    }

    @Override
    protected void onBind(@NonNull ItemUserBinding binding, @NonNull User item) {
        binding.tvName.setText(item.getName());
    }

    @Override
    protected void onCreate(@NonNull ItemUserBinding binding) {
        // [Advanced] Bind payloads in Java to achieve granular updates
        bindPayload(User::getName, (binding, name) -> binding.tvName.setText(name));
    }
}

// 2. Register
adapter.register(User.class, new TypeRouter.Builder<User>()
    .stableId(User::getId)
    .map("DEFAULT", new UserDelegate())
    .build()
);
```

---

## üõ°Ô∏è Robustness & Safety

FusionAdapter introduces a strict **Sanitization** mechanism to ensure UI consistency.

### Global Configuration
Initialize Fusion in your `Application` class:

```kotlin
Fusion.initialize {
    setDebug(BuildConfig.DEBUG) // Fast-fail in Debug, Safe-drop in Release
    setErrorListener { item, e -> 
        // Monitor unregistered types or data errors
        Log.e("Fusion", "Error on item: $item", e)
    }
}
```

---

## üìÑ License

```
Copyright 2024 FusionAdapter Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```